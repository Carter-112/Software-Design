<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Java Data Structures Practice - Binary Search Tree</title>
  <link rel="stylesheet" href="styles.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8347349621527130" crossorigin="anonymous"></script>
  <!-- Fire/Lava Mouse Trail Effect -->
  <script src="mouse-trail.js"></script>
  <!-- External link handler -->
  <script src="external-link-handler.js"></script>
  <script src="solution-fix.js"></script>
  <script src="diagnostic.js"></script>
</head>
<body>
  <header>
    <div class="navbar">
      <div class="dropdown">
        <button class="dropbtn">Navigation ▼</button>
        <div class="dropdown-content">
          <a href="index.html">Home</a>
          <a href="singly.html">Singly</a>
          <a href="doubly.html">Doubly</a>
          <a href="arraylist.html">ArrayList</a>
          <a href="hashmap.html">HashMap</a>
          <a href="hashset.html">HashSet</a>
          <a href="bst.html">BST</a>
          <a href="streams.html">Streams & Lambdas</a>
          <a href="random.html">Random</a>
        </div>
      </div>
    </div>
  </header>

  <!-- Page Content -->
  <div id="content">
    <h1>Binary Search Tree (BST) – Full Class</h1>
    
    <!-- Block 1: Class Declaration, Fields & Constructor -->
    <div class="method">
      <h3>Class Declaration, Fields & Constructor</h3>
      <p class="hint">// The class header, Node inner class, and constructor.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-header-solution')">Check Answer</button>
      <pre id="bst-header-solution"><code>import java.util.Iterator;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Stream;

public class BST&lt;E extends Comparable&lt;E&gt;&gt; implements Iterable&lt;E&gt; {

    // --------------------------------------------------
    // Node Class Definition
    // --------------------------------------------------
    private class Node {
        E value;
        Node left, right;

        public Node(E value) {
            this.value = value;
            left = right = null;
        }
    }

    // Root node of the BST
    private Node root;

    // --------------------------------------------------
    // Constructor
    // --------------------------------------------------
    public BST() {
        root = null;
    }</code></pre>
    </div>
    
    <!-- Block 2: add Method -->
    <div class="method">
      <h3>Add Method</h3>
      <p class="hint">// Add a value to the BST.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-add-solution')">Check Answer</button>
      <pre id="bst-add-solution"><code>// --------------------------------------------------
// Add Method (alias for insert)
// --------------------------------------------------
public void add(E value) {
    root = insertRec(root, value);
}

// Recursive helper method for insert
private Node insertRec(Node node, E value) {
    // Base case: if we've found an empty spot, create a new node
    if (node == null) {
        return new Node(value);
    }
    
    // Otherwise, compare and traverse left or right accordingly
    int cmp = value.compareTo(node.value);
    
    if (cmp < 0) {
        // Value is less, go left
        node.left = insertRec(node.left, value);
    } else if (cmp > 0) {
        // Value is greater, go right
        node.right = insertRec(node.right, value);
    }
    // If cmp == 0, value already exists, do nothing
    
    return node;</code></pre>
    </div>
    
    <!-- Block 3: remove Method -->
    <div class="method">
      <h3>Remove Method</h3>
      <p class="hint">// Remove a value from the BST.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-remove-solution')">Check Answer</button>
      <pre id="bst-remove-solution"><code>// --------------------------------------------------
// Remove Method (by value)
// --------------------------------------------------
public void remove(E value) {
    root = removeRec(root, value);
}

// Recursive helper method for remove
private Node removeRec(Node node, E value) {
    // Base case: If node is null, nothing to remove
    if (node == null) return null;
    
    // Compare value to current node
    int cmp = value.compareTo(node.value);
    
    if (cmp < 0) {
        // Value is less, go left
        node.left = removeRec(node.left, value);
    } else if (cmp > 0) {
        // Value is greater, go right
        node.right = removeRec(node.right, value);
    } else {
        // Found the node to remove
        
        // Case 1: Node with zero or one child
        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        }
        
        // Case 2: Node with two children
        // Find the inorder successor (smallest value in right subtree)
        node.value = findMin(node.right).value;
        
        // Remove the inorder successor
        node.right = removeRec(node.right, node.value);
    }
    
    return node;
}

// Helper method to find minimum value node
private Node findMin(Node node) {
    while (node.left != null) {
        node = node.left;
    }
    return node;</code></pre>
    </div>
    
    <!-- Block 4: contains Method -->
    <div class="method">
      <h3>Contains Method</h3>
      <p class="hint">// Check if a value exists in the BST.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-contains-solution')">Check Answer</button>
      <pre id="bst-contains-solution"><code>// --------------------------------------------------
// Contains Method
// --------------------------------------------------
public boolean contains(E value) {
    return containsRec(root, value);
}

// Recursive helper method for contains
private boolean containsRec(Node node, E value) {
    // Base case: reached a leaf node without finding value
    if (node == null) {
        return false;
    }
    
    // Compare value to current node
    int cmp = value.compareTo(node.value);
    
    if (cmp < 0) {
        // Value is less, search left subtree
        return containsRec(node.left, value);
    } else if (cmp > 0) {
        // Value is greater, search right subtree
        return containsRec(node.right, value);
    } else {
        // Found the value
        return true;
    }
}</code></pre>
    </div>
    
    <!-- Block 5: Normal Traversals -->
    <div class="method">
      <h3>Normal Traversals (Recursive)</h3>
      <p class="hint">// Inorder, Preorder, and Postorder traversals.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-traversals-solution')">Check Answer</button>
      <pre id="bst-traversals-solution"><code>// --------------------------------------------------
// Section 1: Normal Traversals (Recursive)
// --------------------------------------------------
// Inorder Traversal: Left, Root, Right
public void inorder() {
    inorderRec(root);
    System.out.println();
}

private void inorderRec(Node node) {
    if (node != null) {
        inorderRec(node.left);
        System.out.print(node.value + " ");
        inorderRec(node.right);
    }
}

// Preorder Traversal: Root, Left, Right
public void preorder() {
    preorderRec(root);
    System.out.println();
}

private void preorderRec(Node node) {
    if (node != null) {
        System.out.print(node.value + " ");
        preorderRec(node.left);
        preorderRec(node.right);
    }
}

// Postorder Traversal: Left, Right, Root
public void postorder() {
    postorderRec(root);
    System.out.println();
}

private void postorderRec(Node node) {
    if (node != null) {
        postorderRec(node.left);
        postorderRec(node.right);
        System.out.print(node.value + " ");
    }
}</code></pre>
    </div>
    
    <!-- Block 6: Iterator Implementations -->
    <div class="method">
      <h3>Iterator Implementations</h3>
      <p class="hint">// Iterators for inorder, preorder, and postorder traversals.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-iterators-solution')">Check Answer</button>
      <pre id="bst-iterators-solution"><code>// --------------------------------------------------
// Section 2: Traversals using for-each Loop (Iterable)
// --------------------------------------------------
// These custom iterator classes enable using a for‑each loop on an Iterable.

// Inorder Iterator - use Stack to simulate recursion
private class InorderIterator implements Iterator&lt;E&gt; {
    private Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    
    public InorderIterator(Node root) {
        // Push all nodes along leftmost path
        pushLeft(root);
    }
    
    private void pushLeft(Node node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }
    
    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    @Override
    public E next() {
        Node node = stack.pop();
        pushLeft(node.right);
        return node.value;
    }
}

// Preorder Iterator - also uses Stack
private class PreorderIterator implements Iterator&lt;E&gt; {
    private Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    
    public PreorderIterator(Node root) {
        if (root != null) {
            stack.push(root);
        }
    }
    
    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    @Override
    public E next() {
        Node node = stack.pop();
        // Push right first so left gets popped first
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
        return node.value;
    }
}

// Postorder Iterator - collects all nodes in postorder first
private class PostorderIterator implements Iterator&lt;E&gt; {
    private List&lt;E&gt; list;
    private int index;
    
    public PostorderIterator(Node root) {
        list = new ArrayList&lt;&gt;();
        index = 0;
        collectPostorder(root);
    }
    
    private void collectPostorder(Node node) {
        if (node != null) {
            collectPostorder(node.left);
            collectPostorder(node.right);
            list.add(node.value);
        }
    }
    
    @Override
    public boolean hasNext() {
        return index < list.size();
    }
    
    @Override
    public E next() {
        return list.get(index++);
    }
}</code></pre>
    </div>
    
    <!-- Block 7: Iterable Methods -->
    <div class="method">
      <h3>Iterable Methods</h3>
      <p class="hint">// Iterable methods for each traversal order.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-iterable-solution')">Check Answer</button>
      <pre id="bst-iterable-solution"><code>// Iterable methods for each traversal order.
public Iterable&lt;E&gt; getInorderIterable() {
    return () -> new InorderIterator(root);
}
public Iterable&lt;E&gt; getPreorderIterable() {
    return () -> new PreorderIterator(root);
}
public Iterable&lt;E&gt; getPostorderIterable() {
    return () -> new PostorderIterator(root);
}

// The default iterator for this BST (used if you iterate over the BST itself)
// Here, we choose the inorder traversal.
@Override
public Iterator&lt;E&gt; iterator() {
    return new InorderIterator(root);
}</code></pre>
    </div>
    
    <!-- Block 8: Stream Methods -->
    <div class="method">
      <h3>Stream Methods</h3>
      <p class="hint">// Stream methods for each traversal order.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-stream-solution')">Check Answer</button>
      <pre id="bst-stream-solution"><code>// Stream methods for each traversal order.
public Stream&lt;E&gt; inorderStream() {
    List&lt;E&gt; list = new ArrayList&lt;&gt;();
    inorderRec(root, list);
    return list.stream();
}

private void inorderRec(Node node, List&lt;E&gt; list) {
    if (node != null) {
        inorderRec(node.left, list);
        list.add(node.value);
        inorderRec(node.right, list);
    }
}

public Stream&lt;E&gt; preorderStream() {
    List&lt;E&gt; list = new ArrayList&lt;&gt;();
    preorderRec(root, list);
    return list.stream();
}

private void preorderRec(Node node, List&lt;E&gt; list) {
    if (node != null) {
        list.add(node.value);
        preorderRec(node.left, list);
        preorderRec(node.right, list);
    }
}

public Stream&lt;E&gt; postorderStream() {
    List&lt;E&gt; list = new ArrayList&lt;&gt;();
    postorderRec(root, list);
    return list.stream();
}

private void postorderRec(Node node, List&lt;E&gt; list) {
    if (node != null) {
        postorderRec(node.left, list);
        postorderRec(node.right, list);
        list.add(node.value);
    }
}</code></pre>
    </div>
    
    <!-- Block 9: Main Method -->
    <div class="method">
      <h3>Main Method</h3>
      <p class="hint">// A main method demonstrating all the features of the BST.</p>
      <textarea placeholder="Type your code here..."></textarea>
      <button class="check-btn" onclick="toggleSolution('bst-main-solution')">Check Answer</button>
      <pre id="bst-main-solution"><code>// --------------------------------------------------
// Main Method for Testing All Sections
// --------------------------------------------------
public static void main(String[] args) {
    // Create a new BST
    BST&lt;Integer&gt; bst = new BST&lt;&gt;();
    
    // Add some values
    int[] values = {50, 30, 70, 20, 40, 60, 80};
    for (int value : values) {
        bst.add(value);
    }
    
    // Test normal traversals
    System.out.println("Traversals:");
    System.out.print("Inorder: ");
    bst.inorder();
    System.out.print("Preorder: ");
    bst.preorder();
    System.out.print("Postorder: ");
    bst.postorder();
    
    // Test iterator methods
    System.out.println("\nUsing Iterators:");
    System.out.print("Inorder Iterator: ");
    for (Integer i : bst) {
        System.out.print(i + " ");
    }
    System.out.println();
    
    System.out.print("Preorder Iterator: ");
    for (Integer i : bst.getPreorderIterable()) {
        System.out.print(i + " ");
    }
    System.out.println();
    
    System.out.print("Postorder Iterator: ");
    for (Integer i : bst.getPostorderIterable()) {
        System.out.print(i + " ");
    }
    System.out.println();
    
    // Test stream methods
    System.out.println("\nUsing Streams:");
    System.out.print("Inorder Stream: ");
    bst.inorderStream().forEach(e -> System.out.print(e + " "));
    System.out.println();
    
    System.out.print("Preorder Stream: ");
    bst.preorderStream().forEach(e -> System.out.print(e + " "));
    System.out.println();
    
    System.out.print("Postorder Stream: ");
    bst.postorderStream().forEach(e -> System.out.print(e + " "));
    System.out.println();
    
    // Test contains and remove
    System.out.println("\nTest Contains and Remove:");
    System.out.println("Contains 40: " + bst.contains(40));
    System.out.println("Contains 100: " + bst.contains(100));
    
    System.out.print("Before removing 30, inorder: ");
    bst.inorder();
    bst.remove(30);
    System.out.print("After removing 30, inorder: ");
    bst.inorder();
}</code></pre>
    </div>
  </div>

  <script>
    // Function to toggle solution visibility
    function toggleSolution(id) {
      var solution = document.getElementById(id);
      solution.style.display = (solution.style.display === "none" || solution.style.display === "") ? "block" : "none";
    }
  </script>
  <!-- AdSense Integration -->
  <script src="adsense.js"></script>
</body>
</html> 




