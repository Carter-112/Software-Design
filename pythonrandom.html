<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Python Random Practice - Coding Challenges</title>
  <link rel="stylesheet" href="styles.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8347349621527130" crossorigin="anonymous"></script>
  <!-- Fire/Lava Mouse Trail Effect -->
  <script src="mouse-trail.js"></script>
  <script src="diagnostic.js"></script>
  <script src="external-link-handler.js"></script>
  <script src="navigation.js"></script>
  <style>
    body {
      background-color: #222;
      color: #fff;
    }
    
    #content {
      background-color: #222;
      padding: 20px;
      border-radius: 8px;
    }
    
    .code-container {
      background-color: #333;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0 0 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      display: block;
      min-height: 50px;
    }
    
    .code-area {
      background-color: #333;
      color: #eee;
      padding: 10px;
      border-radius: 5px;
      white-space: pre-wrap;
      font-family: monospace;
      display: block;
      min-height: 50px;
      overflow: auto;
      max-height: 500px;
    }
    
    .code-input {
      width: 100%;
      min-height: 150px;
      font-family: monospace;
      padding: 10px;
      margin: 10px 0;
      border: 2px solid #4b8bbe; /* Python blue */
      border-radius: 4px;
      background-color: #282c34;
      color: #eee;
    }
    
    button {
      background-color: #4b8bbe; /* Python blue */
      color: white;
      padding: 10px 20px;
      margin: 10px 5px 10px 0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
      font-weight: bold;
    }
    
    button:hover {
      background-color: #306998; /* Darker Python blue */
    }
    
    h1, h2, h3, h4, h5 {
      color: #ffd43b; /* Python yellow */
    }
    
    #snippetTitle {
      color: #ffd43b;
      font-size: 1.5em;
      margin-bottom: 10px;
    }
    
    #snippetDescription {
      color: #fff;
      margin-bottom: 20px;
    }
    
    /* Fix for solution display */
    #snippetContainer {
      position: relative;
    }
    
    /* Styling for hints */
    .hint-container {
      margin-top: 10px;
      margin-bottom: 20px;
      background-color: rgba(75, 139, 190, 0.2);
      padding: 10px;
      border-left: 4px solid #4b8bbe;
      border-radius: 0 4px 4px 0;
    }
    
    /* No gap between hint and solution */
    h4 {
      margin-top: 0;
      margin-bottom: 10px;
    }

    /* Python syntax highlighting */
    .python-keyword {
      color: #ff79c6;
    }
    
    .python-string {
      color: #f1fa8c;
    }
    
    .python-comment {
      color: #6272a4;
    }
    
    .python-function {
      color: #50fa7b;
    }
    
    /* Additional styling for better display */
    .button-row {
      display: flex;
      margin-top: 15px;
      margin-bottom: 15px;
    }
    
    .snippet-section {
      background-color: rgba(34, 34, 34, 0.7);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .solution-section {
      background-color: rgba(34, 34, 34, 0.7);
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border-left: 4px solid #ffd43b;
      display: block;
    }
  </style>
</head>
<body>
  <header>
    <div class="navbar">
      <div class="dropdown">
        <button class="dropbtn">Navigation ▼</button>
        <div class="dropdown-content">
          <a href="index.html">Home</a>
          
          <!-- Java Data Structures -->
          <div class="nav-category">Java Data Structures</div>
          <a href="singly.html">Singly Linked List</a>
          <a href="doubly.html">Doubly Linked List</a>
          <a href="arraylist.html">ArrayList</a>
          <a href="hashmap.html">HashMap</a>
          <a href="hashset.html">HashSet</a>
          <a href="bst.html">Binary Search Tree</a>
          <a href="streams.html">Streams & Lambdas</a>
          
          <!-- Python Data Structures -->
          <div class="nav-category">Python Data Structures</div>
          <a href="python-lists.html">Lists</a>
          <a href="python-dictionaries.html">Dictionaries</a>
          <a href="python-sets.html">Sets</a>
          <a href="python-tuples.html">Tuples</a>
          <a href="python-comprehensions.html">Comprehensions</a>
          
          <!-- SQL Topics -->
          <div class="nav-category">SQL Topics</div>
          <a href="sql-select.html">SELECT Queries</a>
          <a href="sql-joins.html">JOINs</a>
          <a href="sql-aggregation.html">Aggregation</a>
          <a href="sql-subqueries.html">Subqueries</a>
          <a href="sql-transactions.html">Transactions</a>
          
          <!-- Web Development -->
          <div class="nav-category">Web Development</div>
          <a href="web-html.html">HTML Structure</a>
          <a href="web-css.html">CSS Styling</a>
          <a href="web-js-dom.html">JavaScript DOM</a>
          <a href="web-js-events.html">JavaScript Events</a>
          <a href="web-responsive.html">Responsive Design</a>
          
          <!-- Language Fundamentals -->
          <div class="nav-category">Language Fundamentals</div>
          <a href="javabasics.html">Java Basics</a>
          <a href="pythonbasics.html">Python Basics</a>
          <a href="sqlbasics.html">SQL Basics</a>
          <a href="webbasics.html">HTML/CSS/JS Basics</a>
          
          <!-- Random Practice -->
          <div class="nav-category">Random Practice</div>
          <a href="random.html">Java Random Practice</a>
          <a href="pythonrandom.html">Python Random Practice</a>
          <a href="sqlrandom.html">SQL Random Practice</a>
          <a href="webrandom.html">Web Dev Random Practice</a>
        </div>
      </div>
    </div>
  </header>

  <div id="content">
    <h1>Python Random Practice</h1>
    <p>Test your Python programming skills with these randomly selected coding challenges. Practice Python concepts including data structures, functions, comprehensions, file handling, and more.</p>
    
    <button id="randomSnippetButton" onclick="getRandomSnippet()">Get Random Challenge</button>
    
    <div id="snippetContainer" style="display: none;">
      <div class="snippet-section">
        <h2 id="snippetTitle">Challenge Title</h2>
        <p id="snippetDescription">Challenge description will appear here...</p>
        
        <div class="hint-container" id="hintContainer">
          <h4>Hint:</h4>
          <p id="snippetHint">A helpful hint will appear here...</p>
        </div>
        
        <h3>Write your solution:</h3>
        <textarea id="userCodeInput" class="code-input" placeholder="Write your Python code here..."></textarea>
        
        <div class="button-row">
          <button id="toggleAnswerButton" onclick="toggleRandomAnswer()">Show Solution</button>
        </div>
      </div>
    </div>
    
    <!-- SOLUTION SECTION - Complete replacement -->
    <div id="solutionContainer" style="display: none; background-color: #2d2d2d; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #ffd43b;">
      <h3 style="color: #ffd43b; margin-top: 0;">Solution:</h3>
      <div style="background-color: #333; border-radius: 5px; padding: 15px; margin-top: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <pre id="solutionCode" style="color: #eee; white-space: pre-wrap; font-family: monospace; margin: 0; padding: 0; display: block; overflow: auto; max-height: 500px;"></pre>
      </div>
    </div>
  </div>

  <script>
    // Python challenges database - First part of challenges
    const challenges = [
      {
        title: "List Comprehension",
        description: "Create a list comprehension that generates a list of squares of even numbers from 1 to 20.",
        hint: "Use the range() function and filter with an if condition to get even numbers, then square them.",
        solution: `# List comprehension for squares of even numbers from 1 to 20
even_squares = [x**2 for x in range(1, 21) if x % 2 == 0]
print(even_squares)

# Output: [4, 16, 36, 64, 100, 144, 196, 256, 324, 400]`
      },
      {
        title: "Dictionary Manipulation",
        description: "Given a dictionary of student names and scores, write a function to find all students who scored above 90.",
        hint: "Use a dictionary comprehension or a list comprehension with filtering to select only the students with scores > 90.",
        solution: `def high_scorers(students_dict):
    """Return names of students who scored above 90."""
    return [name for name, score in students_dict.items() if score > 90]

# Test the function
students = {
    "Alice": 95,
    "Bob": 82,
    "Charlie": 91,
    "David": 78,
    "Eva": 98
}

high_performers = high_scorers(students)
print(high_performers)  # Output: ['Alice', 'Charlie', 'Eva']`
      },
      {
        title: "String Manipulation",
        description: "Write a function that takes a string and returns a new string with all vowels removed.",
        hint: "Create a list of vowels to check against, then use either a loop or list comprehension to filter characters.",
        solution: `def remove_vowels(text):
    """Remove all vowels from the input string."""
    vowels = "aeiouAEIOU"
    return ''.join([char for char in text if char not in vowels])

# Test with a sample string
sample = "Hello, World! Python is awesome."
no_vowels = remove_vowels(sample)
print(no_vowels)  # Output: "Hll, Wrld! Pythn s wsm."`
      },
      {
        title: "Lambda Functions",
        description: "Use a lambda function and the sorted() method to sort a list of tuples by the second element.",
        hint: "The sorted() function accepts a 'key' parameter where you can provide a function that extracts the sorting value.",
        solution: `# List of tuples (name, age)
people = [("Alice", 25), ("Bob", 19), ("Charlie", 32), ("David", 22)]

# Sort by the second element (age) using a lambda function
sorted_people = sorted(people, key=lambda x: x[1])

print(sorted_people)
# Output: [('Bob', 19), ('David', 22), ('Alice', 25), ('Charlie', 32)]`
      },
      {
        title: "Error Handling",
        description: "Write a function that safely converts a string to an integer, handling possible exceptions. Return None if the conversion fails.",
        hint: "Use a try/except block to catch ValueError and TypeError exceptions that might occur during conversion.",
        solution: `def safe_int_convert(value):
    """Safely convert a string to an integer, return None if it fails."""
    try:
        return int(value)
    except (ValueError, TypeError):
        return None

# Test with various inputs
print(safe_int_convert("123"))      # Output: 123
print(safe_int_convert("abc"))      # Output: None
print(safe_int_convert("12.5"))     # Output: None
print(safe_int_convert(None))       # Output: None`
      },
      {
        title: "List Filtering",
        description: "Write a function that takes a list of numbers and returns a new list with only the prime numbers.",
        hint: "You'll need a helper function to check if a number is prime, then filter the input list using that function.",
        solution: `def is_prime(number):
    """Check if a number is prime."""
    if number <= 1:
        return False
    if number <= 3:
        return True
    if number % 2 == 0 or number % 3 == 0:
        return False
    i = 5
    while i * i <= number:
        if number % i == 0 or number % (i + 2) == 0:
            return False
        i += 6
    return True

def filter_primes(numbers):
    """Filter a list to keep only prime numbers."""
    return [num for num in numbers if is_prime(num)]

# Test the function
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
prime_nums = filter_primes(nums)
print(prime_nums)  # Output: [2, 3, 5, 7, 11, 13]`
      },
      {
        title: "Working with Sets",
        description: "Given two lists, write a function to find common elements using sets.",
        hint: "Convert both lists to sets, then use the intersection method to find common elements.",
        solution: `def find_common_elements(list1, list2):
    """Find common elements between two lists using sets."""
    set1 = set(list1)
    set2 = set(list2)
    return list(set1.intersection(set2))

# Test the function
first_list = [1, 2, 3, 4, 5, 6]
second_list = [4, 5, 6, 7, 8, 9]
common = find_common_elements(first_list, second_list)
print(common)  # Output: [4, 5, 6] (order might vary as sets are unordered)`
      },
      {
        title: "File Handling",
        description: "Write a function to count the occurrences of each word in a text file. The function should return a dictionary with words as keys and counts as values.",
        hint: "Use the 'with' statement to open the file, then split the content into words and use a dictionary to track counts.",
        solution: `def count_words(filename):
    """Count occurrences of each word in a text file."""
    word_counts = {}
    
    try:
        with open(filename, 'r') as file:
            text = file.read().lower()
            # Remove punctuation and split into words
            import re
            words = re.findall(r'\\b\\w+\\b', text)
            
            # Count the words
            for word in words:
                word_counts[word] = word_counts.get(word, 0) + 1
    
        return word_counts
    except FileNotFoundError:
        print(f"Error: The file {filename} was not found.")
        return {}
    except Exception as e:
        print(f"An error occurred: {e}")
        return {}

# Example usage:
# word_counts = count_words('sample.txt')
# print(word_counts)`
      },
      {
        title: "List Methods",
        description: "Write a function that takes a list of numbers and returns the three largest numbers in descending order.",
        hint: "Sort the list in descending order and return the first three elements.",
        solution: `def get_three_largest(numbers):
    """Return the three largest numbers in descending order."""
    # Sort the list in descending order
    sorted_numbers = sorted(numbers, reverse=True)
    
    # Return the first three elements
    return sorted_numbers[:3]

# Test the function
test_list = [5, 12, 3, 19, 7, 8, 14]
result = get_three_largest(test_list)
print(result)  # Output: [19, 14, 12]`
      },
      {
        title: "Dictionary Methods",
        description: "Create a function that merges two dictionaries, summing values for common keys.",
        hint: "Iterate through the second dictionary and update the first dictionary accordingly.",
        solution: `def merge_dicts_with_sum(dict1, dict2):
    """Merge two dictionaries, summing values for common keys."""
    result = dict1.copy()  # Create a copy of the first dictionary
    
    # Update the result with values from the second dictionary
    for key, value in dict2.items():
        if key in result:
            result[key] += value
        else:
            result[key] = value
    
    return result

# Test the function
dict1 = {'a': 1, 'b': 2, 'c': 3}
dict2 = {'b': 3, 'c': 4, 'd': 5}
merged = merge_dicts_with_sum(dict1, dict2)
print(merged)  # Output: {'a': 1, 'b': 5, 'c': 7, 'd': 5}`
      },
      // Additional challenges from Python files
      {
        title: "List Slicing",
        description: "Given a list of letters, write code to create the following: 1) a subset from index 1 to 4, 2) the first three elements, 3) the last three elements, and 4) every second element.",
        hint: "Use list slicing with the syntax [start:end:step]. Remember that slices don't include the end index.",
        solution: `# List for examples
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']

# Slicing [start:end:step]
subset = letters[1:5]   # ['b', 'c', 'd', 'e'] (end index not included)
first_three = letters[:3]     # ['a', 'b', 'c']
last_three = letters[-3:]     # ['e', 'f', 'g']
every_second = letters[::2]   # ['a', 'c', 'e', 'g']

print(f"Subset: {subset}")
print(f"First three: {first_three}")
print(f"Last three: {last_three}")
print(f"Every second: {every_second}")
`
      },
      {
        title: "Nested List Comprehension",
        description: "Use a nested list comprehension to create a matrix of multiplication results for numbers 1 through 5 (a 5x5 multiplication table).",
        hint: "Use a nested list comprehension with two variables: one for rows and one for columns.",
        solution: `# Create a 5x5 multiplication table using nested list comprehension
multiplication_table = [[i * j for j in range(1, 6)] for i in range(1, 6)]

# Print the matrix in a readable format
for row in multiplication_table:
    print(row)

# Output:
# [1, 2, 3, 4, 5]
# [2, 4, 6, 8, 10]
# [3, 6, 9, 12, 15]
# [4, 8, 12, 16, 20]
# [5, 10, 15, 20, 25]
`
      },
      {
        title: "Dictionary Comprehension",
        description: "Use a dictionary comprehension to create a dictionary with numbers from 1 to 10 as keys and their squares as values.",
        hint: "The syntax for dictionary comprehension is {key: value for item in iterable}.",
        solution: `# Create a dictionary of squares using dictionary comprehension
squares_dict = {num: num**2 for num in range(1, 11)}

print(squares_dict)
# Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100}

# You can also filter items in a dictionary comprehension
even_squares = {num: num**2 for num in range(1, 11) if num % 2 == 0}
print(even_squares)
# Output: {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
`
      },
      {
        title: "Set Operations",
        description: "Given two sets A and B, write code to find: 1) the union, 2) the intersection, 3) elements in A but not in B, and 4) the symmetric difference.",
        hint: "Use set methods or operators like union()/|, intersection()/&, difference()/-, and symmetric_difference()/^.",
        solution: `# Define two sets
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

# Set operations
union = A | B  # or A.union(B)
intersection = A & B  # or A.intersection(B)
difference = A - B  # or A.difference(B)
symmetric_diff = A ^ B  # or A.symmetric_difference(B)

print(f"A: {A}")
print(f"B: {B}")
print(f"Union: {union}")  # All elements from both sets
print(f"Intersection: {intersection}")  # Elements common to both sets
print(f"Difference (A-B): {difference}")  # Elements in A but not in B
print(f"Symmetric Difference: {symmetric_diff}")  # Elements in either set but not in both

# Output:
# A: {1, 2, 3, 4, 5}
# B: {4, 5, 6, 7, 8}
# Union: {1, 2, 3, 4, 5, 6, 7, 8}
# Intersection: {4, 5}
# Difference (A-B): {1, 2, 3}
# Symmetric Difference: {1, 2, 3, 6, 7, 8}
`
      },
      {
        title: "Tuple Unpacking",
        description: "Use tuple unpacking to swap the values of two variables, and then to assign values from a function that returns multiple values.",
        hint: "Tuple unpacking allows you to assign multiple variables at once from an iterable like a tuple.",
        solution: `# Swap two variables using tuple unpacking
a = 5
b = 10
print(f"Before swap: a = {a}, b = {b}")

a, b = b, a  # Tuple unpacking to swap values
print(f"After swap: a = {a}, b = {b}")

# Function that returns multiple values
def get_dimensions():
    return 1920, 1080, "4K"  # Returns a tuple

# Unpack the returned values
width, height, resolution = get_dimensions()
print(f"Width: {width}, Height: {height}, Resolution: {resolution}")

# You can also use _ to ignore values
x, _, z = (1, 2, 3)  # Ignores the middle value
print(f"x = {x}, z = {z}")

# Output:
# Before swap: a = 5, b = 10
# After swap: a = 10, b = 5
# Width: 1920, Height: 1080, Resolution: 4K
# x = 1, z = 3
`
      },
      {
        title: "Function with *args and **kwargs",
        description: "Create a function that calculates the weighted average of an arbitrary number of values, with optional weights provided as keyword arguments.",
        hint: "Use *args to collect positional arguments into a tuple and **kwargs to collect keyword arguments into a dictionary.",
        solution: `def weighted_average(*args, **kwargs):
    """
    Calculate weighted average of values.
    
    Args:
        *args: Values to average
        **kwargs: Can include 'weights' as a list of weights
                 If not provided, equal weights are assumed
    
    Returns:
        float: The weighted average
    """
    if not args:
        return 0
    
    weights = kwargs.get('weights', [1] * len(args))
    
    # Ensure weights and values have the same length
    if len(weights) != len(args):
        weights = weights[:len(args)] + [1] * (len(args) - len(weights))
    
    # Calculate weighted sum and sum of weights
    weighted_sum = sum(val * weight for val, weight in zip(args, weights))
    sum_of_weights = sum(weights)
    
    if sum_of_weights == 0:
        return 0
    
    return weighted_sum / sum_of_weights

# Test the function
print(weighted_average(10, 20, 30))  # Equal weights (1,1,1)
print(weighted_average(10, 20, 30, weights=[2, 1, 3]))  # Custom weights
print(weighted_average(80, 90, 95, 100, weights=[0.10, 0.15, 0.35, 0.40]))  # Grade calculation

# Output:
# 20.0
# 23.333333333333332
# 93.25
`
      },
      {
        title: "Context Manager for File Handling",
        description: "Create a context manager class that opens a file and automatically closes it when the context is exited. Add a feature to log the access.",
        hint: "Implement a class with __enter__ and __exit__ methods to create a context manager.",
        solution: `import time
from datetime import datetime

class FileHandler:
    """Context manager for file handling with logging."""
    
    def __init__(self, filename, mode='r'):
        self.filename = filename
        self.mode = mode
        self.file = None
        self.start_time = None
    
    def __enter__(self):
        """Open the file and log access."""
        self.start_time = time.time()
        self.file = open(self.filename, self.mode)
        print(f"[{datetime.now()}] Opened {self.filename} in {self.mode} mode")
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Close the file and log the duration."""
        if self.file:
            self.file.close()
        end_time = time.time()
        duration = end_time - self.start_time
        print(f"[{datetime.now()}] Closed {self.filename} after {duration:.4f} seconds")
        
        # Log any exceptions
        if exc_type:
            print(f"Exception occurred: {exc_type.__name__}: {exc_val}")
        
        # Return False to propagate exceptions, True to suppress them
        return False

# Example usage
try:
    # Write to a file
    with FileHandler('example.txt', 'w') as file:
        file.write('Hello, World!')
    
    # Read from the file
    with FileHandler('example.txt', 'r') as file:
        content = file.read()
        print(f"File content: {content}")
except Exception as e:
    print(f"Error: {e}")

# Output would include timestamped logs of file opening and closing
# along with the file content
`
      },
      {
        title: "Recursion with Memoization",
        description: "Write a recursive function to calculate the nth Fibonacci number, using memoization to improve performance.",
        hint: "Use a dictionary to store already computed Fibonacci numbers to avoid redundant calculations.",
        solution: `def fibonacci(n, memo={}):
    """Calculate the nth Fibonacci number using recursion with memoization."""
    # Base cases
    if n in memo:
        return memo[n]
    
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    
    # Recursive case with memoization
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]

# Test with some numbers
for i in range(10):
    print(f"F({i}) = {fibonacci(i)}")

# Calculate a larger number (would be very slow without memoization)
print(f"F(100) = {fibonacci(100)}")

# Output:
# F(0) = 0
# F(1) = 1
# F(2) = 1
# F(3) = 2
# F(4) = 3
# F(5) = 5
# F(6) = 8
# F(7) = 13
# F(8) = 21
# F(9) = 34
# F(100) = 354224848179261915075 (a very large number)
`
      },
      {
        title: "Classes and Inheritance",
        description: "Create a base 'Vehicle' class and two derived classes 'Car' and 'Motorcycle' with appropriate methods and attributes.",
        hint: "Use the class keyword to define classes, and pass the base class as a parameter to create a derived class.",
        solution: `class Vehicle:
    """Base class for all vehicles."""
    
    def __init__(self, make, model, year, color):
        self.make = make
        self.model = model
        self.year = year
        self.color = color
        self.is_running = False
    
    def start(self):
        """Start the vehicle's engine."""
        if not self.is_running:
            self.is_running = True
            return f"{self.make} {self.model}'s engine started."
        return f"{self.make} {self.model}'s engine is already running."
    
    def stop(self):
        """Stop the vehicle's engine."""
        if self.is_running:
            self.is_running = False
            return f"{self.make} {self.model}'s engine stopped."
        return f"{self.make} {self.model}'s engine is already off."
    
    def info(self):
        """Return basic info about the vehicle."""
        return f"{self.year} {self.color} {self.make} {self.model}"


class Car(Vehicle):
    """Car class derived from Vehicle."""
    
    def __init__(self, make, model, year, color, num_doors=4):
        # Call the parent class constructor
        super().__init__(make, model, year, color)
        self.num_doors = num_doors
        self.trunk_open = False
    
    def open_trunk(self):
        """Open the car's trunk."""
        if not self.trunk_open:
            self.trunk_open = True
            return "Trunk opened."
        return "Trunk is already open."
    
    def close_trunk(self):
        """Close the car's trunk."""
        if self.trunk_open:
            self.trunk_open = False
            return "Trunk closed."
        return "Trunk is already closed."
    
    def info(self):
        """Override the parent method to include car-specific info."""
        return f"{super().info()}, {self.num_doors} doors"


class Motorcycle(Vehicle):
    """Motorcycle class derived from Vehicle."""
    
    def __init__(self, make, model, year, color, has_sidecar=False):
        # Call the parent class constructor
        super().__init__(make, model, year, color)
        self.has_sidecar = has_sidecar
    
    def wheelie(self):
        """Do a wheelie if the motorcycle is running."""
        if self.is_running:
            return "Doing a wheelie! 🏍️" if not self.has_sidecar else "Can't do a wheelie with a sidecar!"
        return "Start the engine first!"
    
    def info(self):
        """Override the parent method to include motorcycle-specific info."""
        base_info = super().info()
        return f"{base_info}{', with sidecar' if self.has_sidecar else ''}"


# Test the classes
car = Car("Toyota", "Camry", 2022, "Blue", 4)
motorcycle = Motorcycle("Harley", "Davidson", 2021, "Black", False)

print(car.info())
print(car.start())
print(car.open_trunk())

print("\n" + motorcycle.info())
print(motorcycle.start())
print(motorcycle.wheelie())
print(motorcycle.stop())

# Output:
# 2022 Blue Toyota Camry, 4 doors
# Toyota Camry's engine started.
# Trunk opened.
#
# 2021 Black Harley Davidson
# Harley Davidson's engine started.
# Doing a wheelie! 🏍️
# Harley Davidson's engine stopped.
`
      },
      // New challenge for exception handling
      {
        title: "Custom Exception Handling",
        description: "Create a custom exception class and use it to validate a user's age in a function.",
        hint: "Define a custom exception class that inherits from Exception, then raise it in your validation function when needed.",
        solution: `class InvalidAgeError(Exception):
    """Custom exception for invalid age values."""
    
    def __init__(self, age, message="Invalid age provided"):
        self.age = age
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message}: {self.age}"


def validate_age(age):
    """
    Validate a user's age.
    
    Args:
        age: The age to validate
        
    Returns:
        int: The validated age
        
    Raises:
        InvalidAgeError: If age is negative or unreasonably high
        TypeError: If age is not a number
    """
    if not isinstance(age, (int, float)):
        raise TypeError(f"Age must be a number, got {type(age).__name__}")
    
    if age < 0:
        raise InvalidAgeError(age, "Age cannot be negative")
    
    if age > 150:
        raise InvalidAgeError(age, "Age is unreasonably high")
    
    return int(age)


# Test the function with various inputs
test_ages = [25, -5, 200, "thirty", 0, 150]

for age in test_ages:
    try:
        validated_age = validate_age(age)
        print(f"Age {age} is valid: {validated_age}")
    except InvalidAgeError as e:
        print(f"Invalid age error: {e}")
    except TypeError as e:
        print(f"Type error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

# Output:
# Age 25 is valid: 25
# Invalid age error: Age cannot be negative: -5
# Invalid age error: Age is unreasonably high: 200
# Type error: Age must be a number, got str
# Age 0 is valid: 0
# Age 150 is valid: 150`
      },
      
      // New challenge for iterators
      {
        title: "Custom Iterator Implementation",
        description: "Create a custom iterator class that generates the first n Fibonacci numbers.",
        hint: "Implement the __iter__ and __next__ methods in your class to make it an iterator.",
        solution: `class FibonacciIterator:
    """Iterator that generates Fibonacci numbers up to a specified limit."""
    
    def __init__(self, n):
        """Initialize the iterator with a limit of n numbers."""
        self.n = n
        self.count = 0
        self.a, self.b = 0, 1
    
    def __iter__(self):
        """Return the iterator object itself."""
        return self
    
    def __next__(self):
        """Return the next Fibonacci number in the sequence."""
        if self.count >= self.n:
            raise StopIteration
        
        if self.count == 0:
            self.count += 1
            return self.a
        elif self.count == 1:
            self.count += 1
            return self.b
        else:
            result = self.a + self.b
            self.a, self.b = self.b, result
            self.count += 1
            return result


# Test the iterator
fib = FibonacciIterator(10)
print("First 10 Fibonacci numbers:")
for num in fib:
    print(num, end=" ")
# Output: 0 1 1 2 3 5 8 13 21 34

# Using the iterator with list comprehension
fib_iter = FibonacciIterator(15)
fib_list = [num for num in fib_iter]
print(f"\\n\\nFirst 15 Fibonacci numbers: {fib_list}")`
      },
      
      // New challenge for generators
      {
        title: "Generator Functions and Expressions",
        description: "Create a generator function that yields prime numbers up to a given limit, and use it to find the sum of prime numbers under 1000.",
        hint: "Use the 'yield' keyword to create a generator function. Then use the 'next()' function or a for loop to get values from the generator.",
        solution: `def is_prime(n):
    """Check if a number is prime."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    # Check all numbers of the form 6k ± 1 up to sqrt(n)
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True


def prime_generator(limit):
    """Generator function that yields prime numbers up to a limit."""
    num = 2
    while num < limit:
        if is_prime(num):
            yield num
        num += 1


# Use the generator to find sum of primes under 1000
prime_sum = sum(prime_generator(1000))
print(f"Sum of prime numbers under 1000: {prime_sum}")

# Use generator expression to find primes less than 100
primes_under_100 = list(n for n in range(2, 100) if is_prime(n))
print(f"Prime numbers under 100: {primes_under_100}")

# Demonstrate lazy evaluation with a larger generator
large_primes = prime_generator(10000)
print("First 10 primes from a large generator:")
for _ in range(10):
    print(next(large_primes), end=" ")

# Restart with a fresh generator
large_primes = prime_generator(10000)
print("\\n\\nPrimes between 100 and 150:")
for prime in large_primes:
    if prime > 150:
        break
    if prime >= 100:
        print(prime, end=" ")`
      },
      
      // New challenge for decorators
      {
        title: "Advanced Decorators",
        description: "Create a decorator that logs the function name, arguments, and execution time whenever a function is called.",
        hint: "Use a decorator function that accepts *args and **kwargs and passes them to the wrapped function. Use the time module to track execution time.",
        solution: `import time
import functools


def log_execution(func):
    """
    Decorator that logs function name, arguments, and execution time.
    
    Args:
        func: The function to decorate
        
    Returns:
        The wrapped function with logging added
    """
    @functools.wraps(func)  # Preserves function metadata
    def wrapper(*args, **kwargs):
        # Log function name and arguments
        args_str = ', '.join([repr(arg) for arg in args])
        kwargs_str = ', '.join([f"{k}={repr(v)}" for k, v in kwargs.items()])
        all_args = ', '.join(filter(None, [args_str, kwargs_str]))
        print(f"Calling {func.__name__}({all_args})")
        
        # Track execution time
        start_time = time.time()
        
        # Call the original function
        result = func(*args, **kwargs)
        
        # Calculate and log execution time
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"{func.__name__} returned {repr(result)} (took {execution_time:.6f} seconds)")
        
        return result
    
    return wrapper


# Example functions to decorate
@log_execution
def calculate_factorial(n):
    """Calculate the factorial of n."""
    if n <= 1:
        return 1
    return n * calculate_factorial(n - 1)


@log_execution
def find_divisors(number, start=1):
    """Find all divisors of a number starting from a given value."""
    divisors = []
    for i in range(start, number + 1):
        if number % i == 0:
            divisors.append(i)
    return divisors


# Test the decorated functions
print("Testing calculate_factorial:")
factorial_5 = calculate_factorial(5)

print("\\nTesting find_divisors:")
divisors_100 = find_divisors(100, start=10)

# Notice how the recursive factorial calls are all logged`
      },
      
      // New challenge for regular expressions
      {
        title: "Regular Expression Patterns",
        description: "Write a function that extracts all email addresses from a text using regular expressions.",
        hint: "Use the re module and create a pattern that matches the standard email format (name@domain.com).",
        solution: `import re

def extract_emails(text):
    """
    Extract all email addresses from the given text.
    
    Args:
        text: The text to search for email addresses
        
    Returns:
        list: A list of all email addresses found in the text
    """
    # Regular expression pattern for email addresses
    # This pattern matches standard email formats like name@domain.com
    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b'
    
    # Find all matches in the text
    emails = re.findall(email_pattern, text)
    return emails


# Test the function with sample text
sample_text = """
Contact our support team at support@example.com or admin@example.org.
For job inquiries, please email careers@example.net or hr@company.co.uk.
Not valid email addresses: john@.com, @domain.com, user@domain.
But this one is valid: user.name+tag-123@sub.domain-name.co.
"""

# Extract and print all email addresses
extracted_emails = extract_emails(sample_text)
print(f"Found {len(extracted_emails)} email addresses:")
for i, email in enumerate(extracted_emails, 1):
    print(f"{i}. {email}")

# Validate specific email patterns
test_emails = [
    "simple@example.com",
    "very.common@example.com",
    "x@example.com",
    "long.email-address@dept.example.co.uk",
    "user+mailbox@example.com",
    "admin@localhost",  # Technically valid but may not pass some validations
    "@example.com",     # Invalid
    "user@.com",        # Invalid
    "user@domain",      # Not fully qualified
]

print("\\nValidation of test emails:")
for email in test_emails:
    if re.match(r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b', email):
        print(f"{email} - Valid")
    else:
        print(f"{email} - Invalid")`
      },
      
      // New challenge for working with dates and times
      {
        title: "Date and Time Handling",
        description: "Create a function that calculates the number of days between two dates, and another function that formats a datetime object in a user-friendly way.",
        hint: "Use the datetime module to work with dates and times. The timedelta class can help calculate the difference between dates.",
        solution: `from datetime import datetime, timedelta

def days_between_dates(date1, date2):
    """
    Calculate the number of days between two dates.
    
    Args:
        date1: First date (datetime object or string in 'YYYY-MM-DD' format)
        date2: Second date (datetime object or string in 'YYYY-MM-DD' format)
        
    Returns:
        int: The absolute number of days between the two dates
    """
    # Convert string dates to datetime objects if necessary
    if isinstance(date1, str):
        date1 = datetime.strptime(date1, '%Y-%m-%d')
    if isinstance(date2, str):
        date2 = datetime.strptime(date2, '%Y-%m-%d')
    
    # Calculate the difference
    delta = abs(date2 - date1)
    return delta.days


def format_datetime(dt=None, format_type='full'):
    """
    Format a datetime object in a user-friendly way.
    
    Args:
        dt: The datetime object to format (default: current time)
        format_type: Type of formatting to apply ('full', 'date', 'time', 'custom')
        
    Returns:
        str: The formatted datetime string
    """
    if dt is None:
        dt = datetime.now()
    
    formats = {
        'full': '%A, %B %d, %Y at %I:%M %p',  # Monday, January 01, 2023 at 12:30 PM
        'date': '%B %d, %Y',                  # January 01, 2023
        'time': '%I:%M %p',                   # 12:30 PM
        'custom': '%Y-%m-%d %H:%M:%S',        # 2023-01-01 12:30:45
        'iso': '%Y-%m-%dT%H:%M:%S',           # 2023-01-01T12:30:45
        'short': '%d/%m/%Y',                  # 01/01/2023
    }
    
    return dt.strftime(formats.get(format_type, formats['full']))


# Test days between dates
date1 = '2023-01-01'
date2 = '2023-12-31'
print(f"Days between {date1} and {date2}: {days_between_dates(date1, date2)}")

# Test with datetime objects
past_date = datetime(2000, 1, 1)
future_date = datetime(2030, 1, 1)
print(f"Days between {past_date.date()} and {future_date.date()}: {days_between_dates(past_date, future_date)}")

# Test date formatting
current_time = datetime.now()
print(f"Current time (full): {format_datetime(current_time, 'full')}")
print(f"Current time (date): {format_datetime(current_time, 'date')}")
print(f"Current time (time): {format_datetime(current_time, 'time')}")
print(f"Current time (custom): {format_datetime(current_time, 'custom')}")
print(f"Current time (iso): {format_datetime(current_time, 'iso')}")
print(f"Current time (short): {format_datetime(current_time, 'short')}")

# Working with timedeltas
today = datetime.now()
one_week_ago = today - timedelta(days=7)
print(f"One week ago: {format_datetime(one_week_ago, 'full')}")
print(f"30 days from now: {format_datetime(today + timedelta(days=30), 'full')}")`
      },
      
      // New challenge for advanced data handling
      {
        title: "JSON Data Processing",
        description: "Create functions to read a JSON file, manipulate the data, and write the modified data back to a new JSON file.",
        hint: "Use the json module's load/loads to read JSON and dump/dumps to write JSON. Handle potential JSON parsing errors with try-except.",
        solution: `import json
import os
from datetime import datetime

def read_json_file(filename):
    """
    Read and parse a JSON file.
    
    Args:
        filename: Path to the JSON file
        
    Returns:
        The parsed JSON data (typically a dict or list)
        None if there was an error reading or parsing the file
    """
    try:
        with open(filename, 'r') as file:
            data = json.load(file)
        return data
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        return None
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in '{filename}': {e}")
        return None
    except Exception as e:
        print(f"Error reading '{filename}': {e}")
        return None


def write_json_file(data, filename, pretty=True):
    """
    Write data to a JSON file.
    
    Args:
        data: The data to write (must be JSON-serializable)
        filename: Path to the output JSON file
        pretty: Whether to format the JSON for readability
        
    Returns:
        bool: True if successful, False otherwise
    """
    try:
        with open(filename, 'w') as file:
            if pretty:
                json.dump(data, file, indent=2, sort_keys=True)
            else:
                json.dump(data, file)
        return True
    except Exception as e:
        print(f"Error writing to '{filename}': {e}")
        return False


def process_user_data(user_data):
    """
    Process user data by:
    1. Converting timestamps to formatted dates
    2. Calculating age from birth_date
    3. Adding a 'data_processed' timestamp
    
    Args:
        user_data: A list of user records
        
    Returns:
        A processed copy of the user data
    """
    processed_data = []
    
    for user in user_data:
        # Create a copy of the user record
        processed_user = user.copy()
        
        # Convert timestamp to readable date if present
        if 'created_at' in processed_user:
            try:
                timestamp = int(processed_user['created_at'])
                date_str = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
                processed_user['created_at_formatted'] = date_str
            except (ValueError, TypeError):
                processed_user['created_at_formatted'] = 'Invalid timestamp'
        
        # Calculate age if birth_date is present
        if 'birth_date' in processed_user:
            try:
                birth_date = datetime.strptime(processed_user['birth_date'], '%Y-%m-%d')
                today = datetime.now()
                age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
                processed_user['age'] = age
            except (ValueError, TypeError):
                processed_user['age'] = None
        
        # Add a processing timestamp
        processed_user['data_processed'] = datetime.now().isoformat()
        
        processed_data.append(processed_user)
    
    return processed_data


# Example usage with sample data
# In a real application, you would read from an actual file
sample_data = [
    {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com",
        "birth_date": "1990-05-15",
        "created_at": 1609459200  # 2021-01-01 00:00:00
    },
    {
        "id": 2,
        "name": "Jane Smith",
        "email": "jane@example.com",
        "birth_date": "1985-11-30",
        "created_at": 1609545600  # 2021-01-02 00:00:00
    }
]

# Process the data
processed_data = process_user_data(sample_data)

# Print the results
print("Original data:")
print(json.dumps(sample_data, indent=2))

print("\\nProcessed data:")
print(json.dumps(processed_data, indent=2))

# In a real application, you would write to an actual file
# write_json_file(processed_data, 'processed_users.json')`
      },
      
      // New challenge for algorithms
      {
        title: "Efficient Algorithm Implementation",
        description: "Implement a function to find the longest common subsequence of two strings, using dynamic programming for efficiency.",
        hint: "Use a 2D array to store intermediate results. For each position (i,j), calculate whether the characters match and use previously calculated values.",
        solution: `def longest_common_subsequence(text1, text2):
    """
    Find the longest common subsequence of two strings using dynamic programming.
    
    A subsequence is a sequence that can be derived from another sequence by deleting
    some or no elements without changing the order of the remaining elements.
    
    Args:
        text1: First string
        text2: Second string
        
    Returns:
        str: The longest common subsequence
    """
    # Handle edge cases
    if not text1 or not text2:
        return ""
    
    # Create a 2D array to store lengths of LCS for all subproblems
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill the dp table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # Reconstruct the LCS from the dp table
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            lcs.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    
    # Return the LCS (reversed since we built it backwards)
    return ''.join(reversed(lcs))


# Test with some examples
test_cases = [
    ("abcde", "ace", "ace"),
    ("abc", "abc", "abc"),
    ("abc", "def", ""),
    ("AGGTAB", "GXTXAYB", "GTAB"),
    ("programming", "gaming", "gamng")
]

for text1, text2, expected in test_cases:
    result = longest_common_subsequence(text1, text2)
    print(f"LCS of '{text1}' and '{text2}': '{result}'")
    assert result == expected, f"Expected '{expected}', got '{result}'"

# Explanation of the dynamic programming approach
print("\\nExplanation of the DP table for 'abc' and 'abc':")
text1, text2 = "abc", "abc"
m, n = len(text1), len(text2)
dp = [[0] * (n + 1) for _ in range(m + 1)]

# Fill the dp table and visualize it
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if text1[i - 1] == text2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

# Print the DP table
print("   |  '' |  'a' |  'b' |  'c'")
print("---+-----+------+------+------")
for i in range(m + 1):
    if i == 0:
        row_label = " '' |"
    else:
        row_label = f" '{text1[i-1]}' |"
    print(row_label, end="")
    for j in range(n + 1):
        print(f"  {dp[i][j]}  |", end="")
    print()`
      }
    ];

    // Keep track of used indices to avoid repetition
    let usedIndices = [];
    let currentChallengeIndex = -1;

    // Get a random snippet from the database
    function getRandomSnippet() {
      console.log("Getting random snippet. Used indices:", usedIndices);
      // If all challenges have been used, reset the used indices
      if (usedIndices.length >= challenges.length) {
        usedIndices = [];
        console.log("Reset used indices");
      }
      
      // Get a random index that hasn't been used yet
      let randomIndex;
      do {
        randomIndex = Math.floor(Math.random() * challenges.length);
      } while (usedIndices.includes(randomIndex));
      
      usedIndices.push(randomIndex);
      currentChallengeIndex = randomIndex;
      console.log("Selected challenge index:", currentChallengeIndex);
      
      const challenge = challenges[randomIndex];
      
      // Update the DOM with the new challenge
      document.getElementById('snippetTitle').textContent = challenge.title;
      document.getElementById('snippetDescription').textContent = challenge.description;
      document.getElementById('snippetHint').textContent = challenge.hint;
      document.getElementById('userCodeInput').value = ''; // Clear user input
      document.getElementById('snippetContainer').style.display = 'block';
      document.getElementById('solutionContainer').style.display = 'none';
      document.getElementById('toggleAnswerButton').textContent = 'Show Solution';
    }

    // Completely rewritten toggle function with inline styles for reliability
    function toggleRandomAnswer() {
      // Get elements
      const toggleButton = document.getElementById('toggleAnswerButton');
      const solutionContainer = document.getElementById('solutionContainer');
      const solutionCode = document.getElementById('solutionCode');
      
      // Check current visibility state
      const isHidden = solutionContainer.style.display === 'none';
      
      if (isHidden) {
        // SHOW SOLUTION
        
        // Get the solution text
        if (currentChallengeIndex >= 0 && currentChallengeIndex < challenges.length) {
          // Get solution from current challenge
          const solution = challenges[currentChallengeIndex].solution;
          
          // Set solution text content directly
          if (solution) {
            solutionCode.innerHTML = '';  // Clear first
            solutionCode.appendChild(document.createTextNode(solution));  // Add as text node to prevent HTML parsing
          } else {
            solutionCode.innerHTML = 'Solution not available.';
          }
          
          // Show solution container with explicit style
          solutionContainer.style.display = 'block';
          
          // Change button text
          toggleButton.textContent = 'Hide Solution';
          
          // Scroll to solution
          setTimeout(() => {
            solutionContainer.scrollIntoView({behavior: 'smooth', block: 'start'});
          }, 100);
        } else {
          // Handle error
          alert('Error: Could not find solution. Please try another challenge.');
        }
      } else {
        // HIDE SOLUTION
        solutionContainer.style.display = 'none';
        toggleButton.textContent = 'Show Solution';
      }
    }

    // Initialize the page when it loads with robust error handling
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM content loaded, initializing challenge...');
      try {
        // Show the first challenge automatically
      getRandomSnippet();
        console.log('First challenge loaded successfully');
      } catch (error) {
        console.error('Error initializing first challenge:', error);
        // Display a fallback message in the UI if initialization fails
        document.getElementById('snippetTitle').textContent = 'Error Loading Challenge';
        document.getElementById('snippetDescription').textContent = 
          'An error occurred while loading the challenge. Please try refreshing the page.';
        document.getElementById('snippetContainer').style.display = 'block';
      }
    });

    // Additional initialization to ensure proper display of solution
    document.addEventListener('DOMContentLoaded', function() {
      // Pre-cache solution elements
      const solutionContainer = document.getElementById('solutionContainer');
      const solutionCode = document.getElementById('solutionCode');
      
      // Ensure proper styles are applied
      solutionCode.style.whiteSpace = 'pre-wrap';
      solutionCode.style.display = 'block';
      
      // Test solution display mechanism
      console.log("Solution elements initialized:", 
                  solutionContainer ? "Container exists" : "Container missing",
                  solutionCode ? "Code element exists" : "Code element missing");
    });
  </script>
  <!-- AdSense Integration -->
  <script src="adsense.js"></script>
</body>
</html> 